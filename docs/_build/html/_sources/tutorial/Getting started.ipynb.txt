{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Getting started"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Pure component chemical properties."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Chemical objects contain pure component properties:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Chemical: Water (phase_ref='l')\n",
      "[Names]  CAS: 7732-18-5\n",
      "         InChI: H2O/h1H2\n",
      "         InChI_key: XLYOFNOQVPJJNP-U...\n",
      "         common_name: water\n",
      "         iupac_name: oxidane\n",
      "         pubchemid: 962\n",
      "         smiles: O\n",
      "[Groups] Dortmund: <1H2O>\n",
      "         UNIFAC: <1H2O>\n",
      "         PSRK: <1H2O>\n",
      "[Thermo] S_excess(phase, T, P) -> J/mol\n",
      "         H_excess(phase, T, P) -> J/mol\n",
      "         mu(phase, T, P) -> Pa*s\n",
      "         kappa(phase, T, P) -> W/m/K\n",
      "         V(phase, T, P) -> m^3/mol\n",
      "         S(phase, T, P) -> J/mol\n",
      "         H(phase, T) -> J/mol\n",
      "         Cn(phase, T) -> J/mol/K\n",
      "         Psat(T, P=None) -> Pa\n",
      "         Hvap(T, P=None) -> J/mol\n",
      "         sigma(T, P=None) -> N/m\n",
      "         epsilon(T, P=None)\n",
      "[Data]   MW: 18.015 g/mol\n",
      "         Tm: 273.15 K\n",
      "         Tb: 373.12 K\n",
      "         Tt: 273.15 K\n",
      "         Tc: 647.14 K\n",
      "         Pc: 2.2048e+07 Pa\n",
      "         Vc: 5.6e-05 m^3/mol\n",
      "         Zc: 0.22947\n",
      "         Hf: -2.4182e+05 J/mol\n",
      "         Hc: 0 J/mol\n",
      "         Hfus: 6010 J/mol\n",
      "         omega: 0.344\n",
      "         dipole: 1.85\n",
      "         similarity_variable: 0.16653\n"
     ]
    }
   ],
   "source": [
    "import thermosteam as tmo\n",
    "# Initialize with an identifier (e.g. name, CAS, InChI...)\n",
    "water = tmo.Chemical('Water') \n",
    "water # All attributes of a chemical are presented in the IPython display"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The names are strings of chemical identifiers:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'7732-18-5'"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "water.CAS"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The groups are dictionaries of functional groups identifiers for the estimation of activity coefficients through group contribution methods:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<DortmundGroupCounts: 1H2O>"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "water.Dortmund"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The keys are group designation numbers and the values are the number of each group:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{16: 1}"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "dict(water.Dortmund)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Temperature (in Kelvin) and pressure (in Pascal) dependent properties can be computed through the functors:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "101284.55179999319"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Calculate vapor pressure (Pa)\n",
    "water.Psat(T=373.15)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.07205503890847455"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Calculate surface tension (N/m)\n",
    "water.sigma(T=298.15)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "1.687456798143492e-05"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Calculate molar volume (m^3/mol)\n",
    "water.V(T=298.15, P=101325, phase='l')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.0"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Calculate enthalpy at reference conditions (J/mol; without excess energies)\n",
    "water.H(T=298.15, phase='l')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Note that the reference state of all chemicals is 25 $^{\\circ}$C and 1 atm:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "298.15"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "water.T_ref"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "101325.0"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "water.P_ref"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Constant pure component properties are also available:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "18.01528"
      ]
     },
     "execution_count": 11,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Molecular weight (g/mol)\n",
    "water.MW"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "373.124"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Boiling point (K)\n",
    "water.Tb"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Functors"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Temperature dependent properties are managed by model handles (a functor):"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "TDependentModelHandle(T, P=None) -> Psat [Pa]\n",
      "[0] Wagner_McGraw\n",
      "[1] Antoine\n",
      "[2] DIPPR_EQ101\n",
      "[3] Wagner\n",
      "[4] Boiling_Critical_Relation\n",
      "[5] Lee_Kesler\n",
      "[6] Ambrose_Walton\n",
      "[7] Sanjari\n",
      "[8] Edalat\n"
     ]
    }
   ],
   "source": [
    "water.Psat"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "A model handle contains a series of models applicable to a certain domain:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "TDependentModel: Wagner_McGraw\n",
      " evaluate: Wagner_McGraw(T, P=None) -> Psat [Pa]\n",
      " Tmin: 275.00\n",
      " Tmax: 647.35\n"
     ]
    }
   ],
   "source": [
    "water.Psat[0]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "When called, the model handle searches through each model until it finds one with an applicable domain. If none are applicable, you get a value error:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "ename": "ValueError",
     "evalue": "<TDependentModelHandle(T, P=None) -> Psat [Pa]> contains no valid model at T=1000.00 K",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mValueError\u001b[0m                                Traceback (most recent call last)",
      "\u001b[1;32m<ipython-input-15-020628acba16>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0mwater\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mPsat\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;36m1000.0\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[1;32m~\\OneDrive\\Code\\thermosteam\\thermosteam\\base\\thermo_model_handle.py\u001b[0m in \u001b[0;36m__call__\u001b[1;34m(self, T, P)\u001b[0m\n\u001b[0;32m    127\u001b[0m             \u001b[1;32mif\u001b[0m \u001b[0mmodel\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mindomain\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mT\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m \u001b[1;32mreturn\u001b[0m \u001b[0mmodel\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mevaluate\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mT\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    128\u001b[0m         \u001b[1;31m# return model.evaluate(T)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 129\u001b[1;33m         \u001b[1;32mraise\u001b[0m \u001b[0mValueError\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34mf\"{repr(self)} contains no valid model at T={T:.2f} K\"\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    130\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    131\u001b[0m     \u001b[1;32mdef\u001b[0m \u001b[0mdifferentiate_by_T\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mself\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mT\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mP\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;32mNone\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mdT\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;36m1e-12\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;31mValueError\u001b[0m: <TDependentModelHandle(T, P=None) -> Psat [Pa]> contains no valid model at T=1000.00 K"
     ]
    }
   ],
   "source": [
    "water.Psat(1000.0)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Each model contains a functor that stores data to compute the property:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Functor: Wagner_McGraw(T, P=None) -> Psat [Pa]\n",
      " a: -7.7645\n",
      " b: 1.4584\n",
      " c: -2.7758\n",
      " d: -1.233\n",
      " Tc: 647.35 K\n",
      " Pc: 2.2122e+07 Pa\n"
     ]
    }
   ],
   "source": [
    "functor = water.Psat[0].evaluate\n",
    "functor"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<function thermosteam.functors.vapor_pressure.Wagner_McGraw(T, a, b, c, d, Tc, Pc)>"
      ]
     },
     "execution_count": 17,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "functor.function"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'a': -7.7645100000000005,\n",
       " 'b': 1.45838,\n",
       " 'c': -2.7758,\n",
       " 'd': -1.2330299999999998,\n",
       " 'Tc': 647.35,\n",
       " 'Pc': 22122300}"
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "functor.data"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "It may be useful to look at the math:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<IPython.core.display.Image object>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAFsAAAAhCAYAAAC2j9c+AAAABHNCSVQICAgIfAhkiAAAAkpJREFUaIHt2D+MDGEYx/HPXfyJhDtBocEhEQUuOZVE4YKrSYjQUGh0J9FRXNSuopWQSChJRKJSiIZwBI2EbIQT/woXhSic4l0x2Nn5s7c7e+v9Jm9mZ/aZZ377m3fnfeYhEulyxjCbMQ5Xpq7HWILVifEW5/46trAydT3MSmEm769ayP/AXsHstVmB/e3X0hIHcB53MSP8qCuVKvqX7fiM11mBC9qvpSXOYBhf8Qabq5XTkBE8yhPY7TP7JDZhACcq1pLGCB7mCUzO7FX4gL6Mc75jEN9KSSvGnQ5coxUGsUHOmZ00eynOJvaHcFS4azcTxz/qjNHzgRFhchY2u4aJxP5xwexrQg2ZxTiW57lonce4XiC+GxnBF7xqNdEFYfXfkzO+JvutKjkuFdSzS3dWI7lptkAO17dPcuYaEv5SecexwmrLUVNsErTtZqaVfn3YhmnhGT2feanYGjPdLiFpZq8Xyq17BXJ16zN79xzlmW01QZrZv14enhXINY51BeIvm18LZFZJnEma2QP17UyBXEOtSel90sx+Ud+OYwUe4GpHFP3JvvogtC1hh9+VzCec6pCWMdzOiDmipE+n8Q4/MFkmwRwwoXnlUOugltjDrojYw+4guXvYSbq969et5O5hJ4lmlyN3DztJNLsczXrYa3ADU3guvCBGSjIoVGgHG3y3CE8xmohd3CFdPcmosDhubPDdIVxMOzE+RorTrIe9FffTToxmF2dSaLg1aky9x5b6536hHo+0iWW4JTTwprCzWjmRSCQSKctPR4SB+D5HXWsAAAAASUVORK5CYII=\n",
      "text/plain": [
       "<IPython.core.display.Image object>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "tmo.settings.dark_mode = False # Default is True\n",
    "functor.math"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "    Create a functor of temperature (T; in K) that returns the saturated vapor pressure (Psat; in Pa) using the Wagner McGraw equation, as described in [1]_.\n",
      "\n",
      "    .. math::\n",
      "       \\ln P^{sat}= \\ln P_c + \\frac{a\\tau + b \\tau^{1.5} + c\\tau^3 + d\\tau^6} {T_r}\n",
      "       \n",
      "       \\tau = 1 - \\frac{T}{T_c}\n",
      "\n",
      "    Parameters\n",
      "    ----------\n",
      "    Tc : float\n",
      "        Critical point temperature [K].\n",
      "    Pc : float\n",
      "        Critical point pressure [Pa].\n",
      "    a, b, c, d : float\n",
      "        Regressed coefficients.\n",
      "\n",
      "    Notes\n",
      "    -----\n",
      "    Warning: Pc is often treated as adjustable constant.\n",
      "\n",
      "    Examples\n",
      "    --------\n",
      "    Methane, coefficients from [2]_, at 100 K.\n",
      "\n",
      "    >>> Wagner_McGraw(100.0, a=-6.00435, b=1.1885, \n",
      "    ... c=-0.834082, d=-1.22833, Tc=190.53, Pc=4596420.)\n",
      "    34520.44601450496\n",
      "\n",
      "    References\n",
      "    ----------\n",
      "    .. [1] Poling, Bruce E. The Properties of Gases and Liquids. 5th edition.\n",
      "       New York: McGraw-Hill Professional, 2000.\n",
      "    .. [2] McGarry, Jack. \"Correlation and Prediction of the Vapor Pressures of\n",
      "       Pure Liquids over Large Pressure Ranges.\" Industrial & Engineering\n",
      "       Chemistry Process Design and Development 22, no. 2 (April 1, 1983):\n",
      "       313-22. doi:10.1021/i200021a023.\n",
      "    \n"
     ]
    }
   ],
   "source": [
    "# For further help...\n",
    "functor.help()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Phase dependent properties have attributes with model handles for each phase:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<ChemicalPhaseTPProperty(phase, T, P) -> V [m^3/mol]>"
      ]
     },
     "execution_count": 21,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "water.V"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(<TPDependentModelHandle(T, P) -> V.l [m^3/mol]>,\n",
       " <TPDependentModelHandle(T, P) -> V.g [m^3/mol]>)"
      ]
     },
     "execution_count": 22,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "water.V.l, water.V.g"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Note: It is not required to use these models. They can be replaced by your own function or even a constant as shown in the next section."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Pure component thermodynamic models"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The models are ordered in a [deque](https://docs.python.org/3.6/library/collections.html#collections.deque) object to allow for easy reordering:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "deque([<TDependentModel: Wagner_McGraw>,\n",
       "       <TDependentModel: Antoine>,\n",
       "       <TDependentModel: DIPPR_EQ101>,\n",
       "       <TDependentModel: Wagner>,\n",
       "       <TDependentModel: Boiling_Critical_Relation>,\n",
       "       <TDependentModel: Lee_Kesler>,\n",
       "       <TDependentModel: Ambrose_Walton>,\n",
       "       <TDependentModel: Sanjari>,\n",
       "       <TDependentModel: Edalat>])"
      ]
     },
     "execution_count": 23,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "water.Psat.models"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "deque([<TDependentModel: Antoine>,\n",
       "       <TDependentModel: DIPPR_EQ101>,\n",
       "       <TDependentModel: Wagner>,\n",
       "       <TDependentModel: Boiling_Critical_Relation>,\n",
       "       <TDependentModel: Lee_Kesler>,\n",
       "       <TDependentModel: Ambrose_Walton>,\n",
       "       <TDependentModel: Sanjari>,\n",
       "       <TDependentModel: Edalat>,\n",
       "       <TDependentModel: Wagner_McGraw>])"
      ]
     },
     "execution_count": 24,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "water.Psat.models.rotate(-1)\n",
    "water.Psat.models"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "You could also insert your own model:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "TDependentModelHandle(T, P=None) -> Psat [Pa]\n",
      "[0] User_antoine_model\n",
      "[1] user_antoine_model\n",
      "[2] Antoine\n",
      "[3] DIPPR_EQ101\n",
      "[4] Wagner\n",
      "[5] Boiling_Critical_Relation\n",
      "[6] Lee_Kesler\n",
      "[7] Ambrose_Walton\n",
      "[8] Sanjari\n",
      "[9] Edalat\n",
      "[10] Wagner_McGraw\n"
     ]
    }
   ],
   "source": [
    "@water.Psat.model(Tmin=273.20, Tmax=473.20, top=True) # top=True to append left\n",
    "def User_antoine_model(T):\n",
    "    return 10.0**(10.116 -  1687.537 / (T + 42.98))\n",
    "\n",
    "water.Psat"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "You can also set a constant model:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "ConstantThermoModel: Constant\n",
      " value: 1.687e-05\n",
      " Tmin: 0 K\n",
      " Tmax: inf K\n",
      " Pmin: 0 Pa\n",
      " Pmax: inf Pa\n"
     ]
    }
   ],
   "source": [
    "water.V.l.model(1.687e-05)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Ideal mixtures"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In the next example, we make an ideal mixture property package from chemicals:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "IdealMixture([Water, Ethanol, Methanol, Lignin])"
      ]
     },
     "execution_count": 32,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "water =  tmo.Chemical('Water')\n",
    "ethanol = tmo.Chemical('Ethanol')\n",
    "methanol = tmo.Chemical('Methanol')\n",
    "lignin = tmo.Chemical('Lignin')\n",
    "ideal_mixture = tmo.mixture.IdealMixture(chemicals=(water, ethanol, methanol, lignin))\n",
    "ideal_mixture"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<bound method IdealMixture.H of IdealMixture([Water, Ethanol, Methanol, Lignin])>"
      ]
     },
     "execution_count": 33,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "ideal_mixture.H"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "54404.253795065866"
      ]
     },
     "execution_count": 35,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "ideal_mixture.H('l', [0.1, 0.2, 0.3, 0.4], 350, 101325)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
